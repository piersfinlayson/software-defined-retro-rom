# RP2350

While adding support for the Raspberry Pi RP2350 MCU, we learned many interesting things.  This document covers the ones that we haven't forgotten.

In summary:

- It's sort of cheaper and it's sort of not.
- While it has 5V tolerant GPIOs, you may still want to be careful.
- The recommendation layout for the RP235X is extremely painful on such a space constrained, 2-layer board.
- The silicon appears to take about 10ms to come out of reset, with a further approximately 5ms required by the (ROM) bootloader to start our application code.  (One ROM requires a further 2-3ms to startup.)
- Overclocking is entirely feasible - stable operation up to 540MHz with a VREG voltage of 1.6V has been achieved.  A more reasonable recommendation might be 420MHz (1.3V).
- Programming is a bit of a pain.  We found you had to put the device in BOOTSEL mode (pulling BOOT low and resetting), in order to program it via SWD.  Perhaps other software would have worked better than `probe-rs`?
- In some applications (for example the C64 character ROM), the RP2350 can be clocked slower than an STM32.  In some cases (for example the C64 kernal ROM), it needs to be clocked faster.
- Flash XIP cache pinning either doesn't do what we think it does, or is broken.  We tried pinning main_loop() to the XIP cache, but it crashed.  Instead we "warm" the XIP cache, by reading the main_loop() function from flash immediately before executing it.
- It **just worked** - meaning the first PCB layout was a success.  (The firmware didn't quite work first time after porting, but only took a few hours to get running.)

The gory details follow.

## Price

One of the recurring comments we've heard from folks is that the RP2350 is cheaper than the STM32F4 MCUs.  The Raspberry Pi marketing folks have done a fantastic job of convincing people of this - but it **is** true, but isn't really.

Let's take a look at prices.  I use [LCSC](https://lcsc.com) as a price reference, as they are a large, reputable, Chinese component supplier (JLC PCB's component arm), with good prices and stock.  Prices are as of August 2025 and are for single units, unless otherwise stated.

I chose the STM32F411RET6 as the comparison.  Yes, the RP2350 is quite a lot more powerful, but the STM32F411RET6 gets the job done and is a good bang for the buck.

| RP2350A  | STM32F411RET6  |
|----------|----------------|
| $1.74    | $2.69          |

Wow 35% cheaper!  But wait, the RP2350A needs:

- More passives (we'll ignore - they cost fractions of a cent)
- A crystal oscillator
- External flash
- An inductor for the internal voltage regulator 

| Components | RP2350A | STM32F411RET6 |
|------------|---------|---------------|
| MCU        | $1.74   | $2.69         |
| Crystal    | $0.43   | -             |
| Flash*     | $0.53   | -             |
| Inductor*  | $0.28   | -             |
| **Total**  | **$2.98** | **$2.69**   |

\* Flash and inductor not available by the piece - 5 quantity price used.

That's 11% **more expensive**.

In fact, it's worse than this if getting boards assembled, which, face it, you likely will.  Each of the crystal, flash and inductor are JLC PCB "extended" parts, which means a one off additional $3 fee per part, per order.  If you make the minimum batch of 5 boards, this is $9 extra, or $1.80 per board.

Now the RP2350A and supporting components are 67% more expensive than the STM32.

Perhaps we've been a bit unfair here.  In reality we would probably be ordering the GD32F405RGT6 ($3.28).  The per-board cost would be the same at 30 boards, and then the RP2350 based board would get cheaper above that.  And the RP2350 does have that second core, and more RAM and flash ...

The figures above are just for the MCU and supporting components.  For the entire assembled RP2350 PCB (without pins) from JLC you are, as of writing, looking at:
- $44 for 5 - $8.80 each
- $89.50 for 20 - $4.45 each
- $320 for 100 - $3.20 each

Taxes and shipping not included.

## 5V Tolerance

Much has been made of the new RP2350 A4 steppings 5V tolerant GPIOs.  This is true for GPIOs 0-25 - One ROM uses 0-23 to connect to the host.  Also, the input/output voltage thresholds in the datasheet should be compatible with the retro chips tested (mainly Commodore ones).

**But take care of your One ROM.**  The RP2350 has an absolute maximum voltage on any pin of 5.5V.  The original Commodore chips tended to tolerant up to 7V, at least according to their datasheets, and the STM32 is tolerant up to 7.3V.  If you have a retro machine with a suspect voltage regulator or power supply, you may want to consider a STM32 based One ROMs instead.

## Space Constraints and Layout

Due to the physical form factor of the ROMs being replaced by One ROM, and other design choices (the desire to have image select jumpers and the same programming header as the STM version), the entire area of the board for the RP2350, plus supporting componentry is roughly 17mm x 14mm.  A thumbnail if you have big thumbnails.  Or around 1/3 sq inch.

While the RP2350 itself is only 7mm x 7mm, we have to include:
- A voltage regulator (as per the STM32 boards).
- External flash (it is internal on the STM32s).
- External crystal oscillator (it is internal and reasonably good on the STM32s - the internal oscillator on the RP2350 is crap).
- External decoupling and voltage regulator capacitors (similar to the STM32 boards, but more of them).
- A polarised (!) inductor for the internal voltage regulator (not required on the STM32).
- Status LED, resistor and a few pull-ups (per the STM32 boards).

This is around 30 surface mount components in total.  The RP2350 and the 3.2x2.5m crystal are starting to look really quite large now.

As with the STM32 boards it was a design goal to avoid going below 0402 sized components, to make hand-assembly possible (not necessarily easy), and to be able to use the cheapest PCB assembly services.  This means that the smallest capacitors and resistors are 1mm x 0.5mm, and the smallest ICs are 2mm x 2mm (the flash).

At this point you might be thinking "sure, but the STM32 package you use on those boards is huge".  Yes, it is - 14mm x 14mm.  But, and it is a very big but, you can route traces directly underneath it.  The underside of the RP2350 is a solid ground pad, with any remaining space taken up by the 2 required power voltages.  In addition, you're supposed to have stitching vias through the entire ground pad, primarily to help with heat dissipation.  This would mean that you also can't route traces under the RP2350.  This, might then push you, not to a 4-layer board (gains you very little in this case), but to a 6-layer board (expensive).  And/or to very fine traces - but smaller than 6 mils (6/1000ths of an inch) is more expensive to fab.

In the end, with some creative pin assignments (that still allow very similar highly optimised assembly code to the STM32 version), very few stitching vias, and a lot of careful routing, it was possible to fit everything in.  But just barely.  In hardware revision A, only 3 image select jumpers are exposed - although there are 2 more unused GPIOs just waiting to be used.  By the time you read this, there may be a further revisions with more jumpers exposed.

## Power On

Power On delay was measured using an oscilloscope, measuring the time from 3.3V becoming available on the chip, until the main loop started executing.  We know when the main loop has started execting by measuring GPIO 26 to the status LED - it is pulled low at the start of the loop execution (and, in fact, shows bytes being served which is fun!).

We see:
- GPIO 26 go mid-level (~1.8V) at power on, and stay there for 10ms.
- GPIO 26 go high (3.3V) at that point and stay there for 8ms in "normal" operation, with standard and debug logging enabled.
- By removing logging and ROM image preload to RAM we can reduce this down to around 6ms.

This suggests 10ms for the chip to come out of reset, 5ms for the ROM bootloader to start our code, and 1-3ms for our code to get to the main loop (depending on build options).

There are unlikely to be major gains possible here.  It may be possible to speed up the ROM preloading to RAM (which is necessary - serving from ROM would be too slow), by using DMA, but it's only going to save a few ms at best.

## Overclocking

There are a number of considerations when overclocking the RP2350.

### PLL Settings

Simply, the PLL takes the clock source (external crystal in this case), and takes it through an number of multipliers and dividers to generate the system clock.  

The Pico SDK tool `vcocalc.py` is very useful for calculating the settings required, although One ROM generates its own PLL settings based on the frequency requested at build time.

### Flash Speed

The appropriate flash access timing must be set using the QMI `M0_TIMING` register.  The flash chosen for revision A is the W25Q16JV, which has a maximum clock rate of 133MHz.  Beyond that the system clock needs to be divided down.  A divider of 3 is actually the default, but One ROM is more aggressive, and sets is lower if it can according to the target frequency.

### Regulator Voltaage

The stock voltage regulator voltage is 1.1V, which, from testing, is good up to around 300MHz.  Beyond that, the voltage needs to be increased.  420MHz was possible with 1.3V.  Frequencies beyond that need higher voltages, which in turn requires unlocking voltage limits within the RP2350.  540MHz at 1.6V was the highest we were prepared to go.

Your mileage is likely to vary, depending on the exact silicon you have, temperature, cosmic particles, etc.

### Temperature

Running faster, means more power, means more heat.  Revision A has only 2 stitching vias from the RP2350 GND pad to the underside, so its ability to dissipate heat is limited.  If overclocking you would be wise to install a small heat-sink on the RP2350, to monitor temperature, and perhaps expect premature failure of the RP2350.

The RP2350 has an internal temperature sensor, which can be read using the ADC.  When overlocking beyond 300MHz is enabled, One ROM enables the ADC and temperature sensor, and reads it before entering its main loop.  You could continue to read this periodically, either via an external SWD device, or with code running on the second core (which would generate more heat...).

## Programming

During development we mostly used `probe-rs` to program the RP2350 via SWD, while it was installed in a host (a long-suffering Commodore 64).

We found that we had to put the device into BOOTSEL mode (pulling BOOT low and resetting), in order to program it.  This is a bit of a pain, as you have to short a cable from BOOT to GND, and then power cycle the host.  You know when it's in BOOTSEL mode, as the status LED will glow faintly - presmably due to the RP2350 leaving GPIO 26 in an uninitialized state.

We suspect this is due to `probe-rs` not fully resetting the RP2350 before programming it.  If we tried to re-program without pulling in BOOTSEL mode, the first program appeared to work - but hadn't really.  A second time hard-failed.

The same behaviour was observed with a Pico 2.

## Speed vs STM32

To get the obvious comparisions out of the way first:

|        |  RP2350  |  STM32F4 |
|--------|----------|----------|
| Max Speed | 150MHz | 84-180MHz |
| Cortex | M33 | M4 |
| Cores | 2 | 1 |
| Flash | External | Internal |
| RAM | 520KB | 64-192KB |

The code betwen the two types of One ROMs is very, very similar, and in particular, at the time of writing, the assembly main loop basically identical.  You would therefore naively expect the performance to be the same, Hz for Hz between the two devices.  This is not the case.

First, what do we mean by performance?  We mean One ROM serving bytes to the host system, so it behaves correctly and does not crash.  If one MCU can serve a C64 character ROM without visual glitches or host crashes, at 80MHz, but another needs 100MHz, we consider the latter to be slower, and might be very loose and say it's 20% slower, or the other 20% faster.  Yes, our stats teacher would be horrified.  We never liked stats.  But it's all __approximate__ anyway.

Mininimum clock speeds required:

|        |  RP2350  |  STM32F4 |
|--------|----------|----------|
| C64 char ROM | 80Mhz | 80MHz |
| C64 kernal ROM | 90MHz | 84MHz |

Second, why do we think there are differences?  Two key reasons:

- Flash, in particular, caching.
- RAM and bus architecture.

### Flash

The STM32F4xxR series has an Art Accelerator, which appears to cause the flash to behave as if it is zero wait states, at least for One ROM's use cases.  There are some differences between models here - the F405's ART Accelerator is worse than the other, later models, such as the F401, F411 and F446.  Let's forget about the F405 for now.  The ART Accelerator for the others is great.  There appears to be zero touching of flash from within the main loop, and we can erase and re-program the flash while the main loop is running, without any problems.

The RP2350 on the other hand has a quite difference flash architecture.  For one thing, flash is external, and for another the RP2350 has an XIP (eXecute In Place) cache.  We don't fully understand it (see [XIP Cache Pinning](#xip-cache-pinning) later!), but it is a different approach to caching.

We attempt to "warm" the XIP cache by reading the main_loop() function from flash, immediately before executing it.  Maybe this helps, we're not sure.  But we suspect it isn't as good as the STM32's ART Accelerator and hence we think there may be more variability in performance Hz for Hz.

### RAM and Bus Architecture

Like the flash, we think the RAM and bus matric architecture is a bit different between the two MCUs.  We therefore think that the RP2350 may involve a bit more jitter due to bus contention than the STM32.  Having said this, we are currently loading bytes to be served via RAM, and accessing GPIOs via the SIO.  This is probably introducing contention.

We could reduce contention by using either PIOs to serve bytes, or using the Coprocessor port 0.  We will probably try.

We did upload the ROM image to be served to a dedicated SRAM bank to try and reduce contention.  Maybe that helped?

What is the Coprocessor port 0?  It appears to be a direct connection between the Cortex core and the GPIO interface, hence avoiding the bus matrix.

## XIP Cache Pinning

Reading the RP2350 datasheet, in particular 4.4. External Flash and PSRAM (XIP), we concluded that we could "pin" certain flash addresses to the XIP cache, in order to ensure the main_loop() was already loaded into cache, and would be executed from there.

We tried this - by reading the main_loop() function from flash, and then pinning it to the XIP cache - trying pinning jut ways 0 and pinning both ways.  However, this either caused a core lock-up (when pinning both ways and then continuing), or a fault (pinning way 0 then continuing).  We don't know why, but suspect we have misunderstood the XIP cache.

## It Verks

This is what most surprised us, and much as we thought ill of them during PCB layout, the Raspberry Pi engineers have done a cracking job of [Hardware design with RP2350](https://datasheets.raspberrypi.com/rp2350/hardware-design-with-rp2350.pdf).  We read it and re-read it repeatedly during design and layout, and BOM selection, and followed it as closely as possible - and we were rewarded by the design working first time.

Ship it!
