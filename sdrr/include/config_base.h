// Contains configuration definitions and types which are used by the
// configuration generated by `sdrr-gen`. 

// Copyright (C) 2025 Piers Finlayson <piers@piers.rocks>
//
// MIT License

#ifndef CONFIG_BASE_H
#define CONFIG_BASE_H

#include <stdint.h>

// ROM image sizes by type (F1 family)
#define ROM_IMAGE_SIZE_2316  2048
#define ROM_IMAGE_SIZE_2332  4096
#define ROM_IMAGE_SIZE_2364  8192

// Maximum ROM image size (F4 family uses a single size for all ROM types)
#define ROM_IMAGE_SIZE  16384

// ROM image size for sets of more than 1 ROM image
#define ROM_SET_IMAGE_SIZE  65536

// ROM type enumeration
typedef enum {
    ROM_TYPE_2316,
    ROM_TYPE_2332,
    ROM_TYPE_2364
} sdrr_rom_type_t;

// CS state enumeration
typedef enum {
    CS_ACTIVE_LOW,
    CS_ACTIVE_HIGH,
    CS_NOT_USED,
} sdrr_cs_state_t;

// ROM serving algorithm
typedef enum {
    // Original ROM serving algorithm - tests the chip select state(s) twice
    // as often as it loads the ROM data given the address lines state.  This
    // is the default algorithm, and is used for all single ROM sets.
    SERVE_TWO_CS_ONE_ADDR,

    // Serves the byte from RAM only once chip select line(s) active.
    // Very similar to SERVE_ADDR_ON_ANY_CS - but this only matches on all
    // of the required CS lines, that matches on any, so is suitable for
    // multiple ROM sets.
    SERVE_ADDR_ON_CS,

    // Serves the byte from RAM once any of the chip select lines are active.
    // This is used for sets with multiple ROM images, where we don't know the
    // full address (i.e. the image to lookup from) until any of the chip
    // select lines are active.  This is the default algorithm for sets with
    // multiple ROM images on hardware revision F.
    SERVE_ADDR_ON_ANY_CS,
} sdrr_serve_t;

typedef enum {
    PIN_NONE,
    PIN_18,     // This is 23xx pin 18, so CS2 on 2316
    PIN_20,     // This is 23xx pin 20, so CS1 on 2364, 2332 and 2316
    PIN_21,     // This is 23xx pin 21, so CS3 on 2316, CS2 on 2332
#if defined(HW_REV_F)
    PIN_X1,     // This is pin X1 on SDRR, aka STM32F4 PC14 in hw rev f
    PIN_X2,     // This is pin X2 on SDRR, aka STM32F4 PC15 in hw rev f
#endif // HW_REV_F
} sdrr_cs_pin_t;

// ROM information structure
typedef struct {
    sdrr_rom_type_t rom_type;   // ROM type
    sdrr_cs_state_t cs1_state;  // CS1 state
    sdrr_cs_state_t cs2_state;  // CS2 state
    sdrr_cs_state_t cs3_state;  // CS3 state
#if defined(BOOT_LOGGING)
    const char* filename;       // Source filename (BOOT_LOGGING only)
#endif // BOOT_LOGGING
    sdrr_cs_pin_t cs1_line;     // CS1 pin (rom_type=*)
    sdrr_cs_pin_t cs2_line;     // CS2 pin (rom_type = 2316 or 2332)
    sdrr_cs_pin_t cs3_line;     // CS3 pin (rom_type = 2316)
} sdrr_rom_info_t;

// ROM set information structure
//
// SDRR can serve sets of ROM images, which are addressed using the entirety
// of the STM32F4 port C.  This is done in order to emulate multuple ROMs
// simultaneously, with  the additional ROM select lines attached to SDRR via
// X1 and X2.
//
// If the multiple ROM image support is not used, there is be a 1:1 mapping
// between set and image - i.e. `rom_count` is be 1.
typedef struct {
    // Pointer to the data for the ROM image(s) in this set.  Copied to RAM at
    // startup.
    const uint8_t* data;

    // Size of the data for the ROM image(s) in this set.  Used to copy the
    // ROM data to RAM at startup.  This is either:
    // - ROM_IMAGE_SIZE for a single ROM image
    // - ROM_SET_IMAGE_SIZE for a set of multiple ROM images
    const uint32_t size;

    // Pointer to array of pointers to ROMs in this set.
    const sdrr_rom_info_t** roms;

    // The number of unique ROM images in this set.  Used to index the above
    // array.
    const uint8_t rom_count;

    // Which ROM serving algorithm to use for this set.
    const sdrr_serve_t serve;         // ROM serving algorithm

    // CS1 state (active high/low) when using multiple ROM images in this set
    sdrr_cs_state_t multi_rom_cs1_state;  // CS1 state
} sdrr_rom_set_t;

#endif // CONFIG_BASE_H