// Contains configuration definitions and types which are used by the
// configuration generated by `sdrr-gen`. 

// Copyright (C) 2025 Piers Finlayson <piers@piers.rocks>
//
// MIT License

#ifndef CONFIG_BASE_H
#define CONFIG_BASE_H

#include <stdint.h>

typedef enum {
    F401DE = 0x0000,  // 96 KB RAM
    F405 = 0x0001,
    F411 = 0x0002,
    F446 = 0x0003,
    F401BC = 0x0004,  // Only 64KB RAM
    RP2350_LINE = 0x0005,
    MCU_LINE_FORCE_UINT16 = 0xFFFF,
} mcu_line_t;

typedef enum {
    STORAGE_8 = 0x00,
    STORAGE_B = 0x01,
    STORAGE_C = 0x02,
    STORAGE_D = 0x03,
    STORAGE_E = 0x04,
    STORAGE_F = 0x05,
    STORAGE_G = 0x06,
    STORAGE_2MB = 0x07,
    MCU_STORAGE_FORFCE_UINT16 = 0xFFFF,
} mcu_storage_t;

// Only ports A-D are exposed on the 64-pin STM32F4s.
// RP2350 has port (bank) 0.
typedef enum {
    PORT_NONE = 0x00,
    PORT_A    = 0x01,
    PORT_B    = 0x02,
    PORT_C    = 0x03,
    PORT_D    = 0x04,
    PORT_0    = 0x05,  // RP2350
} sdrr_mcu_port_t;

// Pin allocations
//
// All pin numbers are physical pins - allocated from the configured STM32F4
// port.  Valid numbers are 0-15 on the STM32, 0-29 on the RP2350.
// 255 indicates a particular pin is present.
// The index into the array is ROM Address x or Data x number.
#define INVALID_PIN  255
typedef struct {
    // SDRR MCU pin port locations
    // Offset: 0
    // 8 x 1 byte = 8 bytes
    sdrr_mcu_port_t data_port;  // Data lines
    sdrr_mcu_port_t addr_port;  // Address lines
    sdrr_mcu_port_t cs_port;    // Chip select/enable lines
    sdrr_mcu_port_t sel_port;   // Image select jumpers
    sdrr_mcu_port_t status_port; // Status LED
    uint8_t rom_pins;           // Number of pins this ROM is emulating 
    uint8_t reserved1[2];

    // 8 data lines
    // Offset: 8
    // 8 bytes
    uint8_t data[8];

    // Up to 16 address lines.  0xFF indicates unused line.
    // Offset: 16
    // 20 x 1 byte = 20 bytes
    uint8_t addr[16];
    uint8_t reserved2[4];

    // Chip select lines for supported variants
    //
    // x_jumper_pull is the direction of pull from the X1/X2 jumper on the
    // board.  It is 1 if that jumper closing pulls it high, and 0 if it pulls
    // it low.
    //
    // Offset: 36
    // 16 x 1 byte = 16 bytes
    uint8_t cs1_2364;
    uint8_t cs1_2332;
    uint8_t cs1_2316;
    uint8_t cs2_2332;
    uint8_t cs2_2316;
    uint8_t cs3_2316;
    uint8_t x1;
    uint8_t x2;
    uint8_t ce_23128;
    uint8_t oe_23128;
    uint8_t x_jumper_pull;
    uint8_t reserved3[5];

    // Image select lines
    //
    // Sel jumper pull is the direction of pull-up or pull-down when closing
    // the jumper on this board type.  If 1, closing the jumper pulls it up.
    // This is used by One ROM to decide what type of its own pulls to apply
    // (the opposite).  Closing is always interpreted as a 1 by One ROM.
    //
    // Unused image select pins are set to 255.
    //
    // The order of pins in this array is significant - [0] is bit 0 of the
    // interpreted value, [1] bit 1, etc.  If a pin is missing (255) mid
    // array, the _next_ entry will be missing bit.
    //
    // Offset: 52
    // 8 bytes
#define MAX_IMG_SEL_PINS 7
    uint8_t sel[MAX_IMG_SEL_PINS];
    uint8_t sel_jumper_pull;

    // Status LED line
    // Offset: 60
    // 4x1 byte = 4 byte
    uint8_t status;
    uint8_t reserved5[3];

    // Length: 64
} sdrr_pins_t;

// Forward declarations
struct sdrr_rom_set_t;

// Main SDRR information data structure
typedef struct {
    // Magic bytes to identify the firmware and structure
    // Offset: 0
    // 4 bytes
    const char magic[4];  // Magic bytes = "SDRR"

    // Firmware version information
    // Offset: 4
    // 4 x 2 bytes = 8 bytes
    const uint16_t major_version;
    const uint16_t minor_version;
    const uint16_t patch_version;
    const uint16_t build_number;

    // Pointer to build date/time string
    // Offset: 12
    // 4 bytes
    const char* build_date;

    // Git commit hash, NULL terminated
    // Offset: 16
    // 8 bytes
    char commit[8];

    // Hardware revision - pointer to string
    // Offset: 24
    // 4 bytes
    const char* hw_rev;

    // MCU product line
    // Offset: 28
    // 2 x 2 bytes = 4 bytes
    const mcu_line_t mcu_line;
    const mcu_storage_t mcu_storage;

    // Target frequency in MHz
    // Offset: 32
    // 2 + 1 bytes = 3 bytes
    const uint16_t freq;
    const uint8_t overclock;

    // Enable SWD support
    // Offset: 35
    // 1 byte
    const uint8_t swd_enabled;

    // Various debug options
    // Offset: 36
    // 5 x 1 bytes = 5 bytes
    const uint8_t preload_image_to_ram;
    const uint8_t bootloader_capable;
    const uint8_t status_led_enabled;
    const uint8_t boot_logging_enabled;
    const uint8_t mco_enabled;

    // Number of ROM sets - number of entries in the `rom_sets` array 
    // Offset: 41
    // 1 byte
    const uint8_t rom_set_count;

    // Whether access count is enabled
    // Offset: 42
    // 1 byte
    const uint8_t count_rom_access;

    // Reserved for future use
    const uint8_t pad2[1];
    
    // Pointer to array of ROM sets
    // Offset: 44
    // 4 bytes
    const struct sdrr_rom_set_t *rom_sets;

    // Pin allocation structure
    // Offset: 48
    // 4 bytes
    const sdrr_pins_t *pins;

    // Boot configuration.  This is for future use.  For example, an external
    // programmer may change this value, and the SDRR firmware check it on
    // boot, and decide to pre-select an image based on it, rather than the
    // sel jumpers.
    // 
    // As such this is reserved and must be set to 0xff.
    //
    // Offset: 52
    // 4 bytes
    const uint8_t boot_config[4];

    // Length: 56
} sdrr_info_t;

// ROM image sizes by type (F1 family)
#define ROM_IMAGE_SIZE_2316  2048
#define ROM_IMAGE_SIZE_2332  4096
#define ROM_IMAGE_SIZE_2364  8192

// Maximum ROM image size (F4 family uses a single size for all ROM types)
#define ROM_IMAGE_SIZE_STM32F4  16384
#define ROM_IMAGE_SIZE_RP235X   65536

// ROM image size for sets of more than 1 ROM image
#define ROM_SET_IMAGE_SIZE  65536

// ROM type enumeration
typedef enum {
    ROM_TYPE_2316,
    ROM_TYPE_2332,
    ROM_TYPE_2364
} sdrr_rom_type_t;

// CS state enumeration
typedef enum {
    CS_ACTIVE_LOW,
    CS_ACTIVE_HIGH,
    CS_NOT_USED,
} sdrr_cs_state_t;

// ROM serving algorithm
typedef enum {
    // Original ROM serving algorithm - tests the chip select state(s) twice
    // as often as it loads the ROM data given the address lines state.  This
    // is the default algorithm, and is used for all single ROM sets.
    SERVE_TWO_CS_ONE_ADDR,

    // Serves the byte from RAM only once chip select line(s) active.
    // Very similar to SERVE_ADDR_ON_ANY_CS - but this only matches on all
    // of the required CS lines, that matches on any, so is suitable for
    // multiple ROM sets.
    SERVE_ADDR_ON_CS,

    // Serves the byte from RAM once any of the chip select lines are active.
    // This is used for sets with multiple ROM images, where we don't know the
    // full address (i.e. the image to lookup from) until any of the chip
    // select lines are active.  This is the default algorithm for sets with
    // multiple ROM images on hardware revision F.
    SERVE_ADDR_ON_ANY_CS,
} sdrr_serve_t;
#define SERVE_DEFAULT_1_ROM  SERVE_ADDR_ON_CS

// ROM information structure
typedef struct {
    const sdrr_rom_type_t rom_type;   // ROM type
    const sdrr_cs_state_t cs1_state;  // CS1 state
    const sdrr_cs_state_t cs2_state;  // CS2 state
    const sdrr_cs_state_t cs3_state;  // CS3 state
#if defined(BOOT_LOGGING)
    const char* filename;       // Source filename (BOOT_LOGGING only)
#endif // BOOT_LOGGING
} sdrr_rom_info_t;

// ROM set information structure
//
// SDRR can serve sets of ROM images, which are addressed using the entirety
// of the STM32F4 port C.  This is done in order to emulate multuple ROMs
// simultaneously, with  the additional ROM select lines attached to SDRR via
// X1 and X2.
//
// If the multiple ROM image support is not used, there is be a 1:1 mapping
// between set and image - i.e. `rom_count` is be 1.
typedef struct sdrr_rom_set_t {
    // Pointer to the data for the ROM image(s) in this set.  Copied to RAM at
    // startup.
    const uint8_t* data;

    // Size of the data for the ROM image(s) in this set.  Used to copy the
    // ROM data to RAM at startup.  This is either:
    // - ROM_IMAGE_SIZE for a single ROM image
    // - ROM_SET_IMAGE_SIZE for a set of multiple ROM images
    const uint32_t size;

    // Pointer to array of pointers to ROMs in this set.  Note it needs to be
    // a pointer to const pointer to const data, otherwise the linker will
    // decide that the sdrr_rom_info_t structs need to be relocated to RAM
    // on startup, which is unnecessary. 
    const sdrr_rom_info_t* const * roms;

    // The number of unique ROM images in this set.  Used to index the above
    // array.
    const uint8_t rom_count;

    // Which ROM serving algorithm to use for this set.
    const sdrr_serve_t serve;         // ROM serving algorithm

    // CS1 state (active high/low) when using multiple ROM images in this set
    const sdrr_cs_state_t multi_rom_cs1_state;  // CS1 state
} sdrr_rom_set_t;

// SDRR Runtime Information Structure
//
// Contains information about the SDRR runtime environment.
typedef struct sdrr_runtime_info_t {
    // Magic bytes to identify the firmware and structure
    // Offset: 0
    // 4 bytes
    char magic[4];  // Magic bytes = "SDRR"

    // Size of this structure in bytes
    // Offset: 4
    // 1 byte
    uint8_t runtime_info_size;

    // Image select jumper state at boot.
    // Initialized to 0xFF.
    // Offset: 5
    // 1 byte
    uint8_t  image_sel;

    // Index of the currently selected ROM set.  This is chosen at boot via
    // the image select jumpers.
    // Initialized to 0xFF.
    // Offset: 6
    // 1 byte
    uint8_t rom_set_index;

    // Whether the ROM access counting feature is enabled.
    // Initialized to 0x00.
    // Offset: 7
    // 1 byte
    uint8_t count_rom_access;

    // Counter for the number times the CS lines have transitioned from
    // inactive to active.  This is only updated if COUNT_ROM_ACCESS is
    // defined in the configuration.  This field is unused (but present) if
    // COUNT_ROM_ACCESS is not defined.
    // Initialized to 0xFFFFFFFF.  Only set to 0x00000000 if COUNT_ROM_ACCESS
    // is defined, when the ROM starts serving.
    // Offset: 8
    // 4 bytes
    uint32_t access_count;

    // Pointer to the ROM table SDRR uses to serve the ROM data this run
    // Initialized to null.
    // Offset: 12
    // 4 bytes
    void *rom_table;

    // Length of the ROM table SDRR is servig in bytes.
    // Initialized to 0.
    // Offset: 16
    // 4 bytes
    uint32_t rom_table_size;
} sdrr_runtime_info_t;

#endif // CONFIG_BASE_H