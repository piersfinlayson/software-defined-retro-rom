// src/generator.rs
use crate::config::Config;
use crate::rom_types::{CsLogic, StmFamily};
use crate::preprocessor::RomSet;
use anyhow::{Context, Result};
use std::fs;
use std::io::Write;
use std::path::PathBuf;

// Generate all output files
pub fn generate_files(config: &Config, rom_sets: &[RomSet]) -> Result<()> {
    // Create output directory if it doesn't exist
    if !config.output_dir.exists() {
        fs::create_dir_all(&config.output_dir).with_context(|| {
            format!(
                "Failed to create output directory: {}",
                config.output_dir.display()
            )
        })?;
    }

    let family = config.stm_variant.family();
    if family == StmFamily::F1 {
        return Err(anyhow::anyhow!("F1 family is no longer supported"));
    }

    // Generate roms.h
    generate_roms_header_file(config, rom_sets)?;

    // Generate roms.c
    generate_roms_implementation_file(config, rom_sets)?;

    // Generate sdrr_config.h
    generate_sdrr_config_header(config)?;

    // Generate Makefile fragment
    generate_makefile_fragment(config)?;

    // Generate linker script
    generate_linker_script(config)?;

    Ok(())
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FileType {
    C,
    Makefile,
    Linker,
}

fn create_file(output_dir: &PathBuf, filename: &str, filetype: FileType) -> Result<fs::File> {
    let file_path = output_dir.join(filename);
    let mut file = fs::File::create(&file_path)
        .with_context(|| format!("Failed to create file: {}", file_path.display()))?;

    write_header(filename, &mut file, filetype)?;

    Ok(file)
}

fn write_header(name: &str, file: &mut fs::File, filetype: FileType) -> Result<()> {
    let comment = match filetype {
        FileType::C => "//",
        FileType::Makefile => "#",
        FileType::Linker => "",
    };
    if filetype == FileType::Linker {
        writeln!(file, "/*")?;
    }
    writeln!(file, "{comment} {}", name)?;
    writeln!(file)?;
    writeln!(
        file,
        "{comment} This file was auto-generated by sdrr-gen using the following arguments:"
    )?;
    writeln!(file, "{comment}")?;
    writeln!(
        file,
        "{comment}   {}",
        std::env::args().skip(1).collect::<Vec<_>>().join(" ")
    )?;
    writeln!(file, "{comment}")?;
    writeln!(
        file,
        "{comment} Do not edit this file directly - instead rengerate using sdrr-gen."
    )?;
    writeln!(file, "{comment}")?;
    writeln!(
        file,
        "{comment} This is most easily done by modifying the configuration at the beginning"
    )?;
    writeln!(
        file,
        "{comment} of the Makefile in the repostiory root and running `make` from there."
    )?;
    if filetype == FileType::Linker {
        writeln!(file, "*/")?;
    }
    writeln!(file)?;

    Ok(())
}

// Generate roms.h header file
fn generate_roms_header_file(config: &Config, rom_sets: &[RomSet]) -> Result<()> {
    const FILENAME: &str = "roms.h";
    let mut file = create_file(&config.output_dir, FILENAME, FileType::C)?;

    writeln!(file, "#ifndef SDRR_ROMS_H")?;
    writeln!(file, "#define SDRR_ROMS_H")?;
    writeln!(file)?;
    writeln!(file, "#include <stdint.h>")?;
    writeln!(file)?;
    writeln!(file, "// Number of ROM images and sets")?;
    writeln!(file, "#define SDRR_NUM_IMAGES  {}", config.roms.len())?;
    writeln!(file, "#define SDRR_NUM_SETS    {}", rom_sets.len())?;
    writeln!(file)?;

    // ROM set array
    writeln!(file, "// ROM set array")?;
    writeln!(file, "extern const sdrr_rom_set_t rom_set[SDRR_NUM_SETS];")?;
    writeln!(file)?;

    writeln!(file, "#endif // SDRR_ROMS_H")?;

    Ok(())
}

// Generate roms.c implementation file
fn generate_roms_implementation_file(config: &Config, rom_sets: &[RomSet]) -> Result<()> {
    const FILENAME: &str = "roms.c";
    let mut file = create_file(&config.output_dir, FILENAME, FileType::C)?;

    writeln!(file, "#include \"sdrr_config.h\"")?;
    writeln!(file, "#include \"config_base.h\"")?;
    writeln!(file, "#include \"roms.h\"")?;
    writeln!(file)?;

    let family = config.stm_variant.family();

    // Generate filename strings (debug only)
    writeln!(file, "// ROM filenames (BOOT_LOGGING only)")?;
    writeln!(file, "#if defined(BOOT_LOGGING)")?;
    for (i, rom_config) in config.roms.iter().enumerate() {
        let source = rom_config
            .extract
            .as_ref()
            .unwrap_or(&rom_config.original_source);
        let filename = source
            .split('/')
            .last()
            .unwrap_or_else(|| panic!("Failed to extract valid filename from source: {}", source));
        writeln!(
            file,
            "static const char sdrr_rom_{}_filename[] = \"{}\";",
            i, filename
        )?;
    }
    writeln!(file, "#endif // BOOT_LOGGING")?;
    writeln!(file)?;

    // Helper function to convert CsLogic to enum string
    let cs_logic_to_enum = |cs_logic: CsLogic| -> &'static str {
        match cs_logic {
            CsLogic::ActiveLow => "CS_ACTIVE_LOW",
            CsLogic::ActiveHigh => "CS_ACTIVE_HIGH",
            CsLogic::Ignore => "CS_NOT_USED",
        }
    };

    writeln!(
        file,
        "// All objects are static, except for the rom_set array.  This is the only"
    )?;
    writeln!(
        file,
        "// object which should be directly accessed by the rest of the code."
    )?;
    writeln!(file)?;

    // Generate ROM information array
    writeln!(file, "//")?;
    writeln!(file, "// ROM info")?;
    writeln!(file, "//")?;
    writeln!(file)?;

    for (ii, rom_config) in config.roms.iter().enumerate() {
        writeln!(file, "// ROM {}", ii)?;

        writeln!(file, "static const sdrr_rom_info_t rom_{}_info = {{", ii)?;

        let (rom_type_enum, cs1_pin, cs2_pin, cs3_pin) = match rom_config.rom_type {
            crate::rom_types::RomType::Rom2316 => {
                ("ROM_TYPE_2316", "PIN_20", "PIN_NONE", "PIN_NONE")
            }
            crate::rom_types::RomType::Rom2332 => ("ROM_TYPE_2332", "PIN_20", "PIN_21", "PIN_NONE"),
            crate::rom_types::RomType::Rom2364 => ("ROM_TYPE_2364", "PIN_20", "PIN_18", "PIN_21"),
        };

        let cs1_state = cs_logic_to_enum(rom_config.cs_config.cs1);
        let cs2_state = rom_config
            .cs_config
            .cs2
            .map(cs_logic_to_enum)
            .unwrap_or("CS_NOT_USED");
        let cs3_state = rom_config
            .cs_config
            .cs3
            .map(cs_logic_to_enum)
            .unwrap_or("CS_NOT_USED");

        writeln!(file, "    .rom_type = {},", rom_type_enum)?;
        writeln!(file, "    .cs1_state = {},", cs1_state)?;
        writeln!(file, "    .cs2_state = {},", cs2_state)?;
        writeln!(file, "    .cs3_state = {},", cs3_state)?;
        writeln!(file, "#if defined(BOOT_LOGGING)")?;
        writeln!(file, "    .filename = sdrr_rom_{}_filename,", ii)?;
        writeln!(file, "#endif // BOOT_LOGGING")?;
        writeln!(file, "    .cs1_line = {},", cs1_pin)?;
        writeln!(file, "    .cs2_line = {},", cs2_pin)?;
        writeln!(file, "    .cs3_line = {},", cs3_pin)?;
        writeln!(file, "}};")?;
        writeln!(file)?;
    }

    // Add array of pointers for each ROM set, where there is a 1:1 mapping
    // between the ROMs and rom sets
    writeln!(file, "//")?;
    writeln!(file, "// ROM set definitions")?;
    writeln!(file, "//")?;
    writeln!(file)?;

    for rom_set in rom_sets {
        let ii = rom_set.id;
        writeln!(file, "// ROM set {}", ii)?;
        let num_roms = rom_set.roms.len();
        writeln!(file, "#define ROM_SET_{}_ROM_COUNT  {}", ii, num_roms)?;
        if num_roms == 1 {
            writeln!(file, "#define ROM_SET_{}_DATA_SIZE  ROM_IMAGE_SIZE", ii)?;
        } else {
            writeln!(file, "#define ROM_SET_{}_DATA_SIZE  ROM_SET_IMAGE_SIZE", ii)?;
        }
        writeln!(
            file,
            "static const uint8_t rom_set_{}_data[];  // Forward declaration",
            ii
        )?;
        writeln!(
            file,
            "static const sdrr_rom_info_t *rom_set_{}_roms[] = {{",
            ii
        )?;
        for rom_in_set in &rom_set.roms {
            writeln!(file, "    &rom_{}_info,", rom_in_set.original_index)?;
        }
        writeln!(file, "}};")?;
        writeln!(file)?;
    }

    // Create the ROM sets
    writeln!(file, "//")?;
    writeln!(file, "// ROM set array")?;
    writeln!(file, "//")?;
    writeln!(file, "const sdrr_rom_set_t rom_set[SDRR_NUM_SETS] = {{")?;

    for rom_set in rom_sets {
        let ii = rom_set.id;
        writeln!(file, "    {{")?;
        writeln!(file, "        .data = rom_set_{}_data,", ii)?;
        writeln!(file, "        .size = ROM_SET_{}_DATA_SIZE,", ii)?;
        writeln!(file, "        .roms = rom_set_{}_roms,", ii)?;
        writeln!(file, "        .rom_count = ROM_SET_{}_ROM_COUNT,", ii)?;
        writeln!(file, "        .serve = SERVE_TWO_CS_ONE_ADDR,")?;
        writeln!(file, "    }},")?;
    }

    writeln!(file, "}};")?;
    writeln!(file)?;

    // Generate ROM set data arrays
    let hw_rev = config.hw_rev.unwrap();
    for rom_set in rom_sets {
        // Determine image size based on number of ROMs in the set
        let image_size = if rom_set.roms.len() == 1 {
            16384
        } else {
            65536
        };
        let ii = rom_set.id;

        writeln!(file, "// ROM set {} data", rom_set.id)?;
        writeln!(file, "static const uint8_t rom_set_{}_data[ROM_SET_{}_DATA_SIZE] = {{", ii, ii)?;

        for address in 0..image_size {
            if address % 16 == 0 {
                if address > 0 {
                    writeln!(file)?;
                }
                write!(file, "    ")?;
            }
            
            // This would call the new rom_set.get_byte() method I proposed
            let byte = rom_set.get_byte(address, &family, hw_rev);
            write!(file, "0x{:02x}, ", byte)?;
        }

        writeln!(file, "}};")?;
        writeln!(file)?;
    }

    Ok(())
}

// Generate sdrr_config.h header file
fn generate_sdrr_config_header(config: &Config) -> Result<()> {
    const FILENAME: &str = "sdrr_config.h";
    let mut file = create_file(&config.output_dir, FILENAME, FileType::C)?;

    writeln!(file, "#ifndef SDRR_CONFIG_H")?;
    writeln!(file, "#define SDRR_CONFIG_H")?;

    writeln!(file)?;
    writeln!(file, "//")?;
    writeln!(file, "// Hardware configuration")?;
    writeln!(file, "//")?;

    // STM32 variant
    writeln!(file)?;
    writeln!(file, "// STM32 variant")?;
    writeln!(file, "{}", config.stm_variant.define_var_fam())?;
    writeln!(file, "{}", config.stm_variant.define_var_sub_fam())?;
    writeln!(file, "{}", config.stm_variant.define_var_str())?;
    writeln!(file, "{}", config.stm_variant.define_flash_size_bytes())?;
    writeln!(file, "{}", config.stm_variant.define_flash_size_kb())?;
    writeln!(file, "{}", config.stm_variant.define_ram_size_bytes())?;
    writeln!(file, "{}", config.stm_variant.define_ram_size_kb())?;
    writeln!(file)?;
    writeln!(file, "// SDRR hardware variant")?;
    writeln!(file, "{}", config.hw_rev.unwrap().define())?;
    writeln!(file)?;
    if !config.bootloader {
        writeln!(
            file,
            "#define NO_BOOTLOADER 1  // Jumper based bootloader disabled"
        )?;
    } else {
        writeln!(
            file,
            "// #define NO_BOOTLOADER 0  // Jumper based bootloader enabled"
        )?;
    }
    writeln!(file, "// SDRR hardware revision")?;

    writeln!(file)?;
    writeln!(file, "//")?;
    writeln!(file, "// Clocking configuration")?;
    writeln!(file, "//")?;

    // Target frequency
    writeln!(file)?;
    writeln!(file, "// Target frequency")?;
    writeln!(file, "#define TARGET_FREQ_MHZ    {}", config.freq)?;

    // Oscillator config
    writeln!(file)?;
    writeln!(file, "// Oscillator configuration")?;
    if config.hse {
        writeln!(file, "// #define HSI 0")?;
        writeln!(file, "#define HSE 1     // External oscillator selected")?;
    } else {
        writeln!(file, "#define HSI 1     // Internal oscillator selected")?;
        writeln!(file, "// #define HSE 0")?;
    }

    // PLL configuration (F4 family only)
    writeln!(file)?;
    writeln!(file, "// PLL configuration")?;
    if let Some(pll_defines) = config
        .stm_variant
        .generate_pll_defines(config.freq, config.overclock)
    {
        writeln!(file, "{}", pll_defines)?;
        if config.overclock {
            writeln!(file, "#define OVERCLOCK 1  // Overclocking enabled")?;
        } else {
            writeln!(file, "//#define OVERCLOCK 0  // Overclocking disabled")?;
        }
    } else {
        writeln!(file, "// PLL configuration not applicable for this variant")?;
    }

    writeln!(file)?;
    writeln!(file, "//")?;
    writeln!(file, "// Debug and development configuration")?;
    writeln!(file, "//")?;

    // Preload ROM image to RAM
    writeln!(file)?;
    writeln!(file, "// Preload ROM image to RAM")?;
    if config.preload_to_ram {
        writeln!(file, "#define PRELOAD_TO_RAM 1")?;
    } else {
        writeln!(
            file,
            "// #define PRELOAD_TO_RAM 0  // Preloading to RAM disabled"
        )?;
    }

    // SWD
    writeln!(file)?;
    writeln!(file, "// SWD mode")?;
    if config.swd {
        writeln!(file, "#define SWD 1")?;
    } else {
        writeln!(file, "// #define SWD 0  // SWD mode disabled")?;
    }

    // MCO configuration
    writeln!(file)?;
    writeln!(file, "// MCO configuration")?;
    if config.mco {
        writeln!(file, "#define MCO  1")?;
        if config.mco2 {
            writeln!(file, "#define MCO2 1")?;
        } else {
            writeln!(file, "// #define MCO2 0  // MCO2 not used")?;
        }
    } else {
        writeln!(file, "// #define MCO  0  // MCO not used")?;
        writeln!(file, "// #define MCO2 0  // MCO2 not used")?;
    }

    // Boot logging
    writeln!(file)?;
    writeln!(file, "// Boot logging")?;
    if config.boot_logging {
        writeln!(file, "#define BOOT_LOGGING 1")?;
    } else {
        writeln!(file, "// #define BOOT_LOGGING 0  // Boot logging disabled")?;
    }

    // Main loop logging
    writeln!(file)?;
    writeln!(file, "// Main loop logging")?;
    if config.main_loop_logging {
        writeln!(file, "#define MAIN_LOOP_LOGGING 1")?;
    } else {
        writeln!(
            file,
            "// #define MAIN_LOOP_LOGGING 0  // Main loop logging disabled"
        )?;
    }

    // Debug logging
    writeln!(file)?;
    writeln!(file, "// Debug logging")?;
    if config.debug_logging {
        writeln!(file, "#define DEBUG_LOGGING 1")?;
    } else {
        writeln!(
            file,
            "// #define DEBUG_LOGGING 0  // Debug logging disabled"
        )?;
    }

    // Status LED
    writeln!(file)?;
    writeln!(file, "// Status LED")?;
    if config.status_led {
        writeln!(file, "#define STATUS_LED 1")?;
    } else {
        writeln!(file, "// #define STATUS_LED 0  // Status LED not used")?;
    }

    writeln!(file)?;
    writeln!(file, "#endif // SDRR_CONFIG_H")?;

    Ok(())
}

fn generate_makefile_fragment(config: &Config) -> Result<()> {
    const FILENAME: &str = "generated.mk";
    let mut file = create_file(&config.output_dir, FILENAME, FileType::Makefile)?;

    // STM32 variant
    writeln!(file, "# STM32 variant")?;
    writeln!(file, "VARIANT={}", config.stm_variant.makefile_var())?;

    // probe-rs chip-id
    writeln!(file)?;
    writeln!(file, "# probe-rs Chip ID")?;
    writeln!(file, "PROBE_RS_CHIP_ID={}", config.stm_variant.chip_id())?;

    writeln!(file)?;

    Ok(())
}

fn generate_linker_script(config: &Config) -> Result<()> {
    const FILENAME: &str = "linker.ld";
    let mut file = create_file(&config.output_dir, FILENAME, FileType::Linker)?;

    writeln!(file, "MEMORY")?;
    writeln!(file, "{{")?;
    writeln!(
        file,
        "    FLASH (rx) : ORIGIN = 0x08000000, LENGTH = {}K",
        config.stm_variant.flash_storage_kb()
    )?;
    writeln!(
        file,
        "    RAM (xrw)  : ORIGIN = 0x20000000, LENGTH = {}K",
        config.stm_variant.ram_kb()
    )?;
    if let Some(ccm_ram_kb) = config.stm_variant.ccm_ram_kb() {
        writeln!(
            file,
            "    CCMRAM (rw): ORIGIN = 0x10000000, LENGTH = {}K",
            ccm_ram_kb
        )?;
    }
    writeln!(file, "}}")?;
    writeln!(file)?;
    writeln!(file, "INCLUDE stm32f-common.ld")?;

    Ok(())
}
