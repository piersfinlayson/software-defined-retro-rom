// src/generator.rs
use crate::config::Config;
use crate::preprocessor::RomImage;
use crate::rom_types::{CsLogic, StmFamily};
use anyhow::{Context, Result};
use std::fs;
use std::io::Write;
use std::path::PathBuf;

// Generate all output files
pub fn generate_files(config: &Config, rom_images: &[RomImage]) -> Result<()> {
    // Create output directory if it doesn't exist
    if !config.output_dir.exists() {
        fs::create_dir_all(&config.output_dir).with_context(|| {
            format!(
                "Failed to create output directory: {}",
                config.output_dir.display()
            )
        })?;
    }

    // Generate roms.h
    generate_roms_header_file(config, rom_images)?;

    // Generate roms.c
    generate_roms_implementation_file(config, rom_images)?;

    // Generate sdrr_config.h
    generate_sdrr_config_header(config)?;

    // Generate Makefile fragment
    generate_makefile_fragment(config)?;

    Ok(())
}

enum FileType {
    C,
    Makefile,
}

fn create_file(output_dir: &PathBuf, filename: &str, filetype: FileType) -> Result<fs::File> {
    let file_path = output_dir.join(filename);
    let mut file = fs::File::create(&file_path)
        .with_context(|| format!("Failed to create file: {}", file_path.display()))?;

    write_header(filename, &mut file, filetype)?;

    Ok(file)
}

fn write_header(name: &str, file: &mut fs::File, filetype: FileType) -> Result<()> {
    let comment = match filetype {
        FileType::C => "//",
        FileType::Makefile => "#",
    };
    writeln!(file, "{comment} {}", name)?;
    writeln!(file)?;
    writeln!(
        file,
        "{comment} This file was auto-generated by sdrr-gen using the following arguments:"
    )?;
    writeln!(file, "{comment}")?;
    writeln!(
        file,
        "{comment}   {}",
        std::env::args().skip(1).collect::<Vec<_>>().join(" ")
    )?;
    writeln!(file, "{comment}")?;
    writeln!(
        file,
        "{comment} Do not edit this file directly - instead rengerate using sdrr-gen."
    )?;
    writeln!(file, "{comment}")?;
    writeln!(
        file,
        "{comment} This is most easily done by modifying the configuration at the beginning"
    )?;
    writeln!(
        file,
        "{comment} of the Makefile in the repostiory root and running `make` from there."
    )?;
    writeln!(file)?;

    Ok(())
}

// Generate roms.h header file
fn generate_roms_header_file(config: &Config, rom_images: &[RomImage]) -> Result<()> {
    const FILENAME: &str = "roms.h";
    let mut file = create_file(&config.output_dir, FILENAME, FileType::C)?;

    writeln!(file, "#ifndef SDRR_ROMS_H")?;
    writeln!(file, "#define SDRR_ROMS_H")?;
    writeln!(file)?;
    writeln!(file, "#include <stdint.h>")?;
    writeln!(file)?;
    writeln!(file, "// Number of ROM images and sets")?;
    writeln!(file, "#define SDRR_NUM_IMAGES  {}", rom_images.len())?;
    writeln!(file, "#define SDRR_NUM_SETS    SDRR_NUM_IMAGES  // Currently 1:1 mapping")?;
    writeln!(file)?;

    // Generate individual ROM size defines
    writeln!(
        file,
        "// Individual ROM sizes (generated based on actual ROM types)"
    )?;
    let family = config.stm_variant.family();
    for (i, rom_config) in config.roms.iter().enumerate() {
        let size = match family {
            StmFamily::F1 => format!("{}", rom_config.rom_type.size_bytes()),
            StmFamily::F4 => "ROM_IMAGE_SIZE".to_string(),
        };
        writeln!(
            file,
            "#define ROM_{}_SIZE  {}  // {} type",
            i,
            size,
            rom_config.rom_type.name()
        )?;
    }
    writeln!(file)?;

    // ROM set array
    writeln!(file, "// ROM set array")?;
    writeln!(
        file,
        "extern const sdrr_rom_set_t rom_set[SDRR_NUM_SETS];"
    )?;
    writeln!(file)?;

    writeln!(file, "#endif // SDRR_ROMS_H")?;

    Ok(())
}

// Generate roms.c implementation file
fn generate_roms_implementation_file(config: &Config, rom_images: &[RomImage]) -> Result<()> {
    const FILENAME: &str = "roms.c";
    let mut file = create_file(&config.output_dir, FILENAME, FileType::C)?;

    writeln!(file, "#include \"sdrr_config.h\"")?;
    writeln!(file, "#include \"config_base.h\"")?;
    writeln!(file, "#include \"roms.h\"")?;
    writeln!(file)?;

    let family = config.stm_variant.family();

    // Generate filename strings (debug only)
    writeln!(file, "// ROM filenames (BOOT_LOGGING only)")?;
    writeln!(file, "#if defined(BOOT_LOGGING)")?;
    for (i, rom_config) in config.roms.iter().enumerate() {
        let source = rom_config
            .extract
            .as_ref()
            .unwrap_or(&rom_config.original_source);
        let filename = source
            .split('/')
            .last()
            .unwrap_or_else(|| panic!("Failed to extract valid filename from source: {}", source));
        writeln!(
            file,
            "static const char sdrr_rom_{}_filename[] = \"{}\";",
            i, filename
        )?;
    }
    writeln!(file, "#endif // BOOT_LOGGING")?;
    writeln!(file)?;

    writeln!(file, "// All objects are static, except for the rom_set array.  This is the only")?;
    writeln!(file, "// object which should be directly accessed by the rest of the code.")?;
    writeln!(file)?;

    // Generate ROM information array
    writeln!(file, "//")?;
    writeln!(file, "// ROM info")?;
    writeln!(file, "//")?;
    writeln!(file)?;

    // Helper function to convert CsLogic to enum string
    let cs_logic_to_enum = |cs_logic: CsLogic| -> &'static str {
        match cs_logic {
            CsLogic::ActiveLow => "CS_ACTIVE_LOW",
            CsLogic::ActiveHigh => "CS_ACTIVE_HIGH",
        }
    };

    for (ii, rom_config) in config.roms.iter().enumerate() {
        writeln!(file, "// ROM {}", ii)?;

        writeln!(
            file,
            "static const sdrr_rom_info_t rom_{}_info = {{",
            ii
        )?;

        let (rom_type_enum, cs1_pin, cs2_pin, cs3_pin) = match rom_config.rom_type {
            crate::rom_types::RomType::Rom2316 => 
                ("ROM_TYPE_2316", "PIN_20","PIN_NONE", "PIN_NONE"),
            crate::rom_types::RomType::Rom2332 => ("ROM_TYPE_2332", "PIN_20", "PIN_21", "PIN_NONE"),
            crate::rom_types::RomType::Rom2364 => ("ROM_TYPE_2364", "PIN_20", "PIN_18", "PIN_21"),
        };

        let cs1_state = cs_logic_to_enum(rom_config.cs_config.cs1);
        let cs2_state = rom_config
            .cs_config
            .cs2
            .map(cs_logic_to_enum)
            .unwrap_or("CS_NOT_USED");
        let cs3_state = rom_config
            .cs_config
            .cs3
            .map(cs_logic_to_enum)
            .unwrap_or("CS_NOT_USED");

        writeln!(file, "    .rom_type = {},", rom_type_enum)?;
        writeln!(file, "    .cs1_state = {},", cs1_state)?;
        writeln!(file, "    .cs2_state = {},", cs2_state)?;
        writeln!(file, "    .cs3_state = {},", cs3_state)?;
        writeln!(file, "#if defined(BOOT_LOGGING)")?;
        writeln!(file, "    .filename = sdrr_rom_{}_filename,", ii)?;
        writeln!(file, "#endif // BOOT_LOGGING")?;
        writeln!(file, "    .serve = SERVE_ORIG,")?;
        writeln!(file, "    .cs1_line = {},", cs1_pin)?;
        writeln!(file, "    .cs2_line = {},", cs2_pin)?;
        writeln!(file, "    .cs3_line = {},", cs3_pin)?;
        writeln!(file, "}};")?;
        writeln!(file)?;
    }

    // Add array of pointers for each ROM set, where there is a 1:1 mapping
    // between the ROMs and rom sets
    writeln!(file, "//")?;
    writeln!(file, "// ROM set definitions")?;
    writeln!(file, "//")?;
    writeln!(file)?;

    for (ii, _rom_config) in config.roms.iter().enumerate() {
        writeln!(file, "// ROM set {}", ii)?;
        writeln!(file, "#define ROM_SET_{}_ROM_COUNT  {}", ii, 1)?;
        writeln!(file, "#define ROM_SET_{}_DATA_SIZE  ROM_{}_SIZE", ii, ii)?;
        writeln!(file, "static const uint8_t rom_set_{}_data[];  // Forward declaration", ii)?;
        writeln!(file, "static const sdrr_rom_info_t *rom_set_{}_roms[] = {{", ii)?;
        writeln!(file, "    &rom_{}_info,", ii)?;
        writeln!(file, "}};")?;
        writeln!(file)?;
    }

    // Create the ROM sets
    writeln!(file, "//")?;
    writeln!(file, "// ROM set array")?;
    writeln!(file, "//")?;
    writeln!(
        file,
        "const sdrr_rom_set_t rom_set[SDRR_NUM_SETS] = {{"
    )?;

    for (ii, _rom_config) in config.roms.iter().enumerate() {
        writeln!(file, "    {{")?;
        writeln!(file, "        .data = rom_set_{}_data,", ii)?;
        writeln!(file, "        .size = ROM_SET_{}_DATA_SIZE,", ii)?;
        writeln!(file, "        .roms = rom_set_{}_roms,", ii)?;
        writeln!(file, "        .rom_count = ROM_SET_{}_ROM_COUNT,", ii)?;
        writeln!(file, "    }},")?;
    }

    writeln!(file, "}};")?;
    writeln!(file)?;

    // Generate individual ROM data arrays
    for (i, (rom_config, rom)) in config.roms.iter().zip(rom_images.iter()).enumerate() {
        writeln!(file, "// ROM image {} ({})", i, rom_config.rom_type.name())?;
        writeln!(
            file,
            "static const uint8_t rom_set_{}_data[ROM_{}_SIZE] = {{",
            i, i
        )?;

        let rom_len = match family {
            StmFamily::F1 => rom_config.rom_type.size_bytes(),
            StmFamily::F4 => 16384,
        };

        for j in 0..rom_len {
            // 16 bytes per line
            if j % 16 == 0 {
                if j > 0 {
                    writeln!(file)?;
                }
                write!(file, "    ")?;
            }

            let byte = rom.get_byte(j, &family, &rom_config.rom_type);
            write!(file, "0x{:02x}, ", byte)?;
        }

        writeln!(file)?;
        writeln!(file, "}};")?;
        writeln!(file)?;
    }

    Ok(())
}

// Generate sdrr_config.h header file
fn generate_sdrr_config_header(config: &Config) -> Result<()> {
    const FILENAME: &str = "sdrr_config.h";
    let mut file = create_file(&config.output_dir, FILENAME, FileType::C)?;

    writeln!(file, "#ifndef SDRR_CONFIG_H")?;
    writeln!(file, "#define SDRR_CONFIG_H")?;

    writeln!(file)?;
    writeln!(file, "//")?;
    writeln!(file, "// Hardware configuration")?;
    writeln!(file, "//")?;

    // STM32 variant
    writeln!(file)?;
    writeln!(file, "// STM32 variant")?;
    writeln!(file, "{}", config.stm_variant.define_var_fam())?;
    writeln!(file, "{}", config.stm_variant.define_var_sub_fam())?;
    writeln!(file, "{}", config.stm_variant.define_var_str())?;
    writeln!(file, "{}", config.stm_variant.define_flash_size())?;
    writeln!(file)?;
    writeln!(file, "// SDRR hardware variant")?;
    writeln!(file, "{}", config.hw_rev.unwrap().define())?;
    writeln!(file)?;
    if !config.bootloader {
        writeln!(
            file,
            "#define NO_BOOTLOADER 1  // Jumper based bootloader disabled"
        )?;
    } else {
        writeln!(
            file,
            "// #define NO_BOOTLOADER 0  // Jumper based bootloader enabled"
        )?;
    }
    writeln!(file, "// SDRR hardware revision")?;

    writeln!(file)?;
    writeln!(file, "//")?;
    writeln!(file, "// Clocking configuration")?;
    writeln!(file, "//")?;

    // Target frequency
    writeln!(file)?;
    writeln!(file, "// Target frequency")?;
    writeln!(file, "#define TARGET_FREQ_MHZ    {}", config.freq)?;

    // Oscillator config
    writeln!(file)?;
    writeln!(file, "// Oscillator configuration")?;
    if config.hse {
        writeln!(file, "// #define HSI 0")?;
        writeln!(file, "#define HSE 1     // External oscillator selected")?;
    } else {
        writeln!(file, "#define HSI 1     // Internal oscillator selected")?;
        writeln!(file, "// #define HSE 0")?;
    }

    // PLL configuration (F4 family only)
    writeln!(file)?;
    writeln!(file, "// PLL configuration")?;
    if let Some(pll_defines) = config
        .stm_variant
        .generate_pll_defines(config.freq, config.overclock)
    {
        writeln!(file, "{}", pll_defines)?;
        if config.overclock {
            writeln!(file, "#define OVERCLOCK 1  // Overclocking enabled")?;
        } else {
            writeln!(file, "//#define OVERCLOCK 0  // Overclocking disabled")?;
        }
    } else {
        writeln!(file, "// PLL configuration not applicable for this variant")?;
    }

    writeln!(file)?;
    writeln!(file, "//")?;
    writeln!(file, "// Debug and development configuration")?;
    writeln!(file, "//")?;

    // Preload ROM image to RAM
    writeln!(file)?;
    writeln!(file, "// Preload ROM image to RAM")?;
    if config.preload_to_ram {
        writeln!(file, "#define PRELOAD_TO_RAM 1")?;
    } else {
        writeln!(
            file,
            "// #define PRELOAD_TO_RAM 0  // Preloading to RAM disabled"
        )?;
    }

    // SWD
    writeln!(file)?;
    writeln!(file, "// SWD mode")?;
    if config.swd {
        writeln!(file, "#define SWD 1")?;
    } else {
        writeln!(file, "// #define SWD 0  // SWD mode disabled")?;
    }

    // MCO configuration
    writeln!(file)?;
    writeln!(file, "// MCO configuration")?;
    if config.mco {
        writeln!(file, "#define MCO  1")?;
        if config.mco2 {
            writeln!(file, "#define MCO2 1")?;
        } else {
            writeln!(file, "// #define MCO2 0  // MCO2 not used")?;
        }
    } else {
        writeln!(file, "// #define MCO  0  // MCO not used")?;
        writeln!(file, "// #define MCO2 0  // MCO2 not used")?;
    }

    // Boot logging
    writeln!(file)?;
    writeln!(file, "// Boot logging")?;
    if config.boot_logging {
        writeln!(file, "#define BOOT_LOGGING 1")?;
    } else {
        writeln!(file, "// #define BOOT_LOGGING 0  // Boot logging disabled")?;
    }

    // Main loop logging
    writeln!(file)?;
    writeln!(file, "// Main loop logging")?;
    if config.main_loop_logging {
        writeln!(file, "#define MAIN_LOOP_LOGGING 1")?;
    } else {
        writeln!(
            file,
            "// #define MAIN_LOOP_LOGGING 0  // Main loop logging disabled"
        )?;
    }

    // Debug logging
    writeln!(file)?;
    writeln!(file, "// Debug logging")?;
    if config.debug_logging {
        writeln!(file, "#define DEBUG_LOGGING 1")?;
    } else {
        writeln!(
            file,
            "// #define DEBUG_LOGGING 0  // Debug logging disabled"
        )?;
    }

    // Status LED
    writeln!(file)?;
    writeln!(file, "// Status LED")?;
    if config.status_led {
        writeln!(file, "#define STATUS_LED 1")?;
    } else {
        writeln!(file, "// #define STATUS_LED 0  // Status LED not used")?;
    }

    writeln!(file)?;
    writeln!(file, "#endif // SDRR_CONFIG_H")?;

    Ok(())
}

fn generate_makefile_fragment(config: &Config) -> Result<()> {
    const FILENAME: &str = "generated.mk";
    let mut file = create_file(&config.output_dir, FILENAME, FileType::Makefile)?;

    // STM32 variant
    writeln!(file, "# STM32 variant")?;
    writeln!(file, "VARIANT={}", config.stm_variant.makefile_var())?;

    // probe-rs chip-id
    writeln!(file)?;
    writeln!(file, "# probe-rs Chip ID")?;
    writeln!(file, "PROBE_RS_CHIP_ID={}", config.stm_variant.chip_id())?;

    writeln!(file)?;

    Ok(())
}
