// Copyright (C) 2025 Piers Finlayson <piers@piers.rocks>
//
// MIT License

//! sdrr-gen - File handling logic for the SDRR generator.
//!
//! Primarily handles sourcing ROM image files from local paths or URLs,
//! including downloading and caching them as needed.

use anyhow::{Context, Result};
use bytes::Bytes;
use std::collections::HashMap;
use std::fmt;
use std::fs::{File, OpenOptions, copy, create_dir_all, remove_dir_all};
use std::io::{Cursor, Read, Write};
use std::path::{Path, PathBuf};
use std::sync::LazyLock;
use strum::EnumIter;
use urlencoding::decode;
use zip::ZipArchive;

use crate::config::Config;
use crate::preprocessor::RomImage;

// Files generated by generator.rs
const ROMS_C_FILE: &str = "roms.c";
const ROMS_H_FILE: &str = "roms.h";
const SDRR_CONFIG_H_FILE: &str = "sdrr_config.h";
const SDRR_CONFIG_C_FILE: &str = "sdrr_config.c";
const GEN_MK_FILE: &str = "generated.mk";
const LINKER_LD_FILE: &str = "linker.ld";

// Directory for ROM images
const IMAGE_DIR: &str = "images";

// Filename containing names of all ROM images
const IMAGE_LIST_FILE: &str = "image_list.txt";

#[derive(Debug, Clone, Copy, Eq, Hash, PartialEq, EnumIter)]
pub enum OutType {
    RomsC,
    RomsH,
    SdrrConfigH,
    SdrrConfigC,
    GenMk,
    LinkerLd,
}

static OUT_FILES: LazyLock<HashMap<OutType, String>> = LazyLock::new(|| {
    let mut map = HashMap::new();
    map.insert(OutType::RomsC, ROMS_C_FILE.to_string());
    map.insert(OutType::RomsH, ROMS_H_FILE.to_string());
    map.insert(OutType::SdrrConfigH, SDRR_CONFIG_H_FILE.to_string());
    map.insert(OutType::SdrrConfigC, SDRR_CONFIG_C_FILE.to_string());
    map.insert(OutType::GenMk, GEN_MK_FILE.to_string());
    map.insert(OutType::LinkerLd, LINKER_LD_FILE.to_string());
    map
});

// Return the output filename for a given output type
pub fn out_filename(out_type: OutType) -> PathBuf {
    PathBuf::from(
        OUT_FILES
            .get(&out_type)
            .cloned()
            .expect("Internal error - unknown output file type"),
    )
}

// Return an iterator over the output filenames
fn out_filenames_iter() -> impl Iterator<Item = String> {
    OUT_FILES.values().cloned()
}

// Return the directory where generated files are stored
fn image_dir(output_dir: &Path) -> PathBuf {
    output_dir.join(IMAGE_DIR)
}

pub fn image_list_file(output_dir: &Path) -> PathBuf {
    image_dir(output_dir).join(IMAGE_LIST_FILE)
}

/// Check if the output directory is valid and does not contain existing
/// files that would be overwritten.
///
/// Returns OK(PathBuf) containing the output directory path, or
/// Err(String) with an error message.
pub fn check_output_dir(out_dir: &Path, overwrite: bool) -> Result<(), String> {
    let image_dir = image_dir(out_dir);

    if !overwrite && out_dir.exists() {
        for file_name in out_filenames_iter() {
            let file_path = out_dir.join(&file_name);
            if file_path.exists() {
                return Err(format!(
                    "Output directory already exists and contains '{}'. Use --overwrite to replace it.",
                    file_name
                ));
            }
        }

        for dir_name in &[out_dir, &image_dir] {
            let dir_path = out_dir.join(dir_name);
            if dir_path.exists() {
                return Err(format!(
                    "Output directory {}/{} already exists. Use --overwrite to potentially overwrite files in it.",
                    out_dir.display(),
                    dir_name.display(),
                ));
            }
        }
    }

    clean_image_dir(out_dir)
}

fn clean_image_dir(output_dir: &Path) -> Result<(), String> {
    // Delete any existing image directory
    let image_dir = image_dir(output_dir);
    remove_dir_all(&image_dir)
        .or_else(|_| std::fs::create_dir_all(&image_dir))
        .map_err(|e| format!("Failed to remove existing image directory: {}", e))?;

    create_dir_all(&image_dir).map_err(|e| format!("Failed to create image directory: {}", e))?;

    // Create the image list file
    File::create(image_list_file(output_dir))
        .map_err(|e| format!("Failed to create image list file: {}", e))?
        .write_all("List of ROM image files used to build this ROM:\n\n".as_bytes())
        .map_err(|e| format!("Failed to write to image list file: {}", e))
}

fn update_image_list(rom_num: usize, src: &FileSource, out_dir: &Path) -> Result<(), String> {
    let image_list_path = image_list_file(out_dir);
    let mut file = OpenOptions::new()
        .append(true)
        .open(&image_list_path)
        .map_err(|e| format!("Failed to open image list file: {}", e))?;

    writeln!(file, "ROM #{rom_num}: {}.rom - {}", rom_num, src)
        .map_err(|e| format!("Failed to write to image list file: {}", e))?;

    Ok(())
}

/// Sources a ROM image file, either from the local file system, a URL, or, if
/// in a zip archive, extracts it from there.
pub fn source_image_file(
    rom_num: usize,
    source: &FileSource,
    out_dir: &Path,
) -> Result<PathBuf, String> {
    // Create filename for this ROM
    let image_dir = image_dir(out_dir);
    let out_filename = PathBuf::from(format!("{rom_num}.rom"));
    let out_file = image_dir.join(out_filename);

    // Get the file and put in the image directory
    match &source {
        FileSource::Local(path) => copy_local_file(path, &out_file)?,
        FileSource::Url(url) => download_url(&out_file, url)?,
        FileSource::UrlZip(url, extract_file) => {
            download_and_extract_zip(&out_file, url, extract_file)?
        }
    };

    update_image_list(rom_num, source, out_dir)
        .map_err(|e| format!("Failed to update image list: {}", e))?;

    Ok(out_file)
}

// Load the ROM files based on the configuration
pub fn load_rom_files(config: &Config) -> Result<Vec<RomImage>> {
    let mut rom_images = Vec::new();
    for rom_config in config.roms.iter() {
        let rom_image = RomImage::load_from_file(
            &rom_config.file,
            &rom_config.rom_type,
            &rom_config.size_handling,
        )
        .with_context(|| {
            format!(
                "Failed to process ROM image: {}",
                rom_config.original_source
            )
        })?;
        rom_images.push(rom_image);
    }
    Ok(rom_images)
}

fn copy_local_file(src: &Path, dest: &Path) -> Result<(), String> {
    println!("Copying {} to {}", src.display(), dest.display());

    // Copy it to the image directory
    copy(src, dest).map_err(|e| format!("Failed to copy file: {e}"))?;

    // Check it got there
    if dest.exists() {
        Ok(())
    } else {
        Err(format!(
            "Failed to copy file {} to cache directory {}",
            src.display(),
            dest.display()
        ))
    }
}

fn download_file(url: &str) -> Result<Bytes, String> {
    let response =
        reqwest::blocking::get(url).map_err(|e| format!("Failed to download {url}: {e}"))?;

    response
        .bytes()
        .map_err(|e| format!("Failed to read download {url}: {e}"))
}

fn download_url(dest_file: &Path, url: &str) -> Result<(), String> {
    println!("Downloading {url} to {}", dest_file.display());

    let bytes = download_file(url)?;

    let mut file =
        File::create(dest_file).map_err(|e| format!("Failed to create download file: {e}"))?;
    file.write_all(&bytes)
        .map_err(|e| format!("Failed to write download file: {}", e))?;

    Ok(())
}

fn download_and_extract_zip(dest_file: &Path, url: &str, extract_file: &str) -> Result<(), String> {
    // URL decode the extract filename to handle spaces and special characters
    let decoded_extract_file = decode(extract_file)
        .map_err(|e| format!("Failed to URL decode extract filename '{extract_file}': {e}"))?;

    println!(
        "Downloading and extracting {decoded_extract_file} from {url} to {}",
        dest_file.display()
    );

    let bytes = download_file(url)?;

    let cursor = Cursor::new(bytes);
    let mut archive =
        ZipArchive::new(cursor).map_err(|e| format!("Failed to open zip archive: {}", e))?;

    // First, collect all filenames and check if our target exists
    let mut file_names = Vec::new();
    let mut target_exists = false;

    // Iterate through the archive to find the target file
    for i in 0..archive.len() {
        if let Ok(f) = archive.by_index(i) {
            let name = f.name().to_string();
            if name == decoded_extract_file {
                target_exists = true;
            }
            file_names.push(name);
        }
    }

    // Couldn't find it
    if !target_exists {
        println!("Failed to find '{decoded_extract_file}' in zip. Archive contents:",);
        for name in &file_names {
            println!("  '{}'", name);
        }
        return Err(format!("Failed to find {decoded_extract_file} in zip"));
    }

    // Now we know the file exists, extract it
    let mut file = archive
        .by_name(&decoded_extract_file)
        .map_err(|e| format!("Failed to extract {decoded_extract_file}: {e}"))?;

    let mut contents = Vec::new();
    file.read_to_end(&mut contents)
        .map_err(|e| format!("Failed to read {extract_file} from zip: {e}"))?;

    // Save it off in the destination dir
    let mut file =
        File::create(dest_file).map_err(|e| format!("Failed to create extracted file: {e}"))?;
    file.write_all(&contents)
        .map_err(|e| format!("Failed to write extracted file: {e}"))?;

    Ok(())
}

pub enum FileSource {
    Local(PathBuf),
    Url(String),
    UrlZip(String, String), // URL and file to extract from the zip
}

impl fmt::Display for FileSource {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            FileSource::Local(path) => write!(f, "{}", path.to_str().unwrap_or("Internal error")),
            FileSource::Url(url) => write!(f, "{}", url),
            FileSource::UrlZip(url, extract) => write!(f, "{extract} from {url}"),
        }
    }
}
